"""Provides the CrossoverEmitter."""

import numpy as np

from ribs._utils import check_batch_shape
from ribs.emitters._emitter_base import EmitterBase
from src.moribs.emitters.operators import CrossoverOperator


class CrossoverEmitter(EmitterBase):
    """Emits solutions by mixing the parameters of two parents.

    Args:
        archive (ribs.archives.ArchiveBase): An archive to use when creating and
            inserting solutions. For instance, this can be
            :class:`ribs.archives.GridArchive`.
        crossover_proportion (float): The proportion of parameters that should
            be mixed.
        initial_solutions (array-like): An (n, solution_dim) array of solutions
            to be used when the archive is empty. If this argument is None, then
            solutions will be sampled uniformly within the solution space defined
            by bounds.
        bounds (None or array-like): Bounds of the solution space. Solutions are
            clipped to these bounds. Pass None to indicate there are no bounds.
            Alternatively, pass an array-like to specify the bounds for each
            dim. Each element in this array-like can be None to indicate no
            bound, or a tuple of ``(lower_bound, upper_bound)``, where
            ``lower_bound`` or ``upper_bound`` may be None to indicate no bound.
        batch_size (int): Number of solutions to return in :meth:`ask`.
        seed (int): Value to seed the random number generator. Set to None to
            avoid a fixed seed.
    Raises:
        ValueError: The archive is empty at the time when ask() is called.
        ValueError: There is an error in the bounds configuration.
    """

    def __init__(
        self,
        archive,
        *,
        crossover_proportion,
        initial_solutions=None,
        bounds=None,
        batch_size=64,
        seed=None
    ):
        self._rng = np.random.default_rng(seed)
        self._batch_size = batch_size

        self._crossover_proportion = crossover_proportion

        self._initial_solutions = None
        if initial_solutions is not None:
            self._initial_solutions = np.asarray(initial_solutions)
            check_batch_shape(
                self._initial_solutions,
                "initial_solutions",
                archive.solution_dim,
                "archive.solution_dim",
            )

        EmitterBase.__init__(
            self,
            archive,
            solution_dim=archive.solution_dim,
            bounds=bounds,
        )

        self._operator = CrossoverOperator(
            crossover_proportion=self._crossover_proportion,
            lower_bounds=self._lower_bounds,
            upper_bounds=self._upper_bounds,
            seed=seed,
        )

    @property
    def initial_solutions(self):
        """numpy.ndarray: The initial solutions which are returned when the
        archive is empty."""
        return self._initial_solutions

    @property
    def crossover_proportion(self):
        """float: The proportion of parameters that should
        be mixed."""
        return self._crossover_proportion

    @property
    def batch_size(self):
        """int: Number of solutions to return in :meth:`ask`."""
        return self._batch_size

    def ask(self):
        """Generates ``batch_size`` solutions.

        If the archive is empty and ``self._initial_solutions`` is set, we
        return ``self._initial_solutions``.
        Otherwise, solutions are generated by first randomly sampling ``2 * self._batch_size``
        parents from the archive, and then calling CrossoverOperator on sampled parents.

        Returns:
            If the archive is not empty, ``(batch_size, solution_dim)`` array
            -- contains ``batch_size`` new solutions to evaluate. If the
            archive is empty, we return ``self._initial_solutions``, which
            might not have ``batch_size`` solutions.
        """
        if self.archive.empty and self._initial_solutions is not None:
            return np.clip(
                self._initial_solutions, self.lower_bounds, self.upper_bounds
            )

        if self.archive.empty:
            raise ValueError(
                "The archive cannot be empty when ask() is called unless initial_solutions is set."
            )
        else:
            parents = self.archive.sample_elites(2 * self._batch_size)[
                "solution"
            ]
        return self._operator.ask(
            parents=parents.reshape(2, self._batch_size, -1)
        )
